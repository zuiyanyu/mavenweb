package javaBase.多线程.线程状态02;

/**
 * TODO 线程状态
 * TODO 1.线程可以有六种状态 ，
 * 1.1 New （新创建）
 * 1.2 Runnable (可运行)
 * 1.3 Blocked (被阻塞)
 * 1.4 Waiting (等待)
 * 1.5 Timed Waiting (计时等待)
 * 1.6 Terminated(被终止)
 *
 * TODO 2. getState()确定一个线程的状态
 *
 * TODO 3. 线程状态解释
 * 1.1 新创建线程   New （新创建）
 *      1.1.1 当用 new 操作符创建一个新线程时， 如 newThread(r)， 该线程还没有开始运行。这意味着它的状态是 new。
 *      1.1.2 当一个线程处于新创建状态时， 程序还没有开始运行线程中的代码。
 * 1.2 可运行线程  Runnable (可运行)
 *      TODO  在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行.)
 *      1.2.1 一旦调用 start 方法，线程处于 runnable 状态。
 *      1.2.2 一个可运行的线程可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。
 *      1.2.3 （Java 的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。）
 *      1.2.4 一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。
 *      1.2.5 TODO 线程调度的细节依赖于操作系统提供的服务 (现在所有的桌面以及服务器操作系统都使用抢占式调度。)
 *      抢占式调度系统给每一个可运行线程一个时间片来执行任务。 当时间片用完，操作系统剥夺该线程的运行权， 并给另一个线程运行机会
 *      当选择下一个线程时， 操作系统考虑线程的优先级.
 *      (像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用 yield 方法、 或者被阻塞或等待时，线程才失去控制权。)
 *      1.2.6 TODO 在具有多个处理器的机器上，每一个处理器运行一个线程,可以有多个线程并行运行。
 *            TODO 当然， 如果线程的数目多于处理器的数目， 调度器依然采用时间片机制。
 *
 * 1.3 被阻塞线程和等待线程 Blocked (被阻塞)、 Waiting (等待) 、Timed Waiting (计时等待)
 *      1.3.1 当线程处于被阻塞或等待状态时，它暂时不活动，直到线程调度器重新激活它。它不运行任何代码且消耗最少的资源。
 *      1.3.2 TODO 细节取决于线程是怎样达到非活动状态的。
 *      • 当一个线程试图获取一个内部的对象锁（而不是 java.util.Concurrent 库中的锁，) 而该锁被其他线程持有， 则该线程进入阻塞状态.
 *        当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。
 *
 *      • 当线程等待另一个线程通知调度器一个条件时， 它自己进入等待状态。
 *        在调用 Object.wait 方法或 Thread.join 方法，
 *        或者是等待 java,util.concurrent 库中的 Lock 或 Condition 时， 就会出现这种情况。
 *
 *       TODO 实际上，被阻塞状态与等待状态是有很大不同的。
 *
 *      • 有几个方法有一个超时参数。调用它们导致线程进人计时等待（ timed waiting) 状态。
 *        这一状态将一直保持到超时期满或者接收到适当的通知。
 *        带有超时参数的方法有Thread.sleep 和 Object.wait、 Thread.join、 Lock,tryLock 以及 Condition.await 的计时版。
 *
 *      1.3.3 TODO 当一个线程被阻塞或等待时（或终止时，) 另一个线程被调度为可运行状态。
 *            TODO 当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁，)调度器检查它是否具有比当前运行线程更高的优
 *            TODO 先级。 如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。
 *
 * 1.6 被终止的线程  Terminated(被终止)
 * TODO 线程因如下两个原因之一而被终止：
 *    • 因为 run 方法正常退出而自然死亡。
 *    • 因为一个没有捕获的异常终止了。
 *
 *    特别是， 可以调用线程的 stop 方法杀死一个线程。 该方法抛出 ThreadDeath 错误对象,由此杀死线程。
 *    TODO    但是，stop 方法已过时， 不要在自己的代码中调用这个方法。
 */
public class Thread_6_State {
    /**
     * TODO  java.Iang.Thread 1.0
     *
     *
     *
     *
     *
     */
}
